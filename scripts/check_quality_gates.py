#!/usr/bin/env python3
"""Compare coverage and Ruff metrics against the stored baselines."""

from __future__ import annotations

import argparse
import json
import sys
import xml.etree.ElementTree as ET
from pathlib import Path

import yaml


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Verify that the repository's coverage and Ruff violation count meet the "
            "quality gate baselines."
        )
    )
    parser.add_argument(
        "--baseline",
        type=Path,
        required=True,
        help="Path to the YAML file that stores the baseline metrics.",
    )
    parser.add_argument(
        "--coverage",
        type=Path,
        required=True,
        help="Path to the coverage XML generated by pytest-cov.",
    )
    parser.add_argument(
        "--ruff",
        type=Path,
        required=True,
        help="Path to the Ruff JSON report generated with --output-format json.",
    )
    return parser.parse_args()


def load_baselines(path: Path) -> dict:
    try:
        with path.open("r", encoding="utf-8") as handle:
            data = yaml.safe_load(handle)
    except FileNotFoundError as exc:
        raise SystemExit(f"Baseline file not found: {path}") from exc
    if not isinstance(data, dict):
        raise SystemExit("Baseline file must define a mapping of metrics.")
    return data


def read_coverage_percent(coverage_path: Path) -> float:
    try:
        tree = ET.parse(coverage_path)
    except FileNotFoundError as exc:
        raise SystemExit(f"Coverage report not found: {coverage_path}") from exc
    except ET.ParseError as exc:
        raise SystemExit(f"Coverage report is not valid XML: {coverage_path}") from exc

    line_rate = tree.getroot().attrib.get("line-rate")
    if line_rate is None:
        raise SystemExit("Coverage report is missing the line-rate attribute.")
    return float(line_rate) * 100.0


def read_ruff_violation_count(report_path: Path) -> int:
    try:
        with report_path.open("r", encoding="utf-8") as handle:
            payload = json.load(handle)
    except FileNotFoundError as exc:
        raise SystemExit(f"Ruff report not found: {report_path}") from exc
    except json.JSONDecodeError as exc:
        raise SystemExit(f"Ruff report is not valid JSON: {report_path}") from exc

    if isinstance(payload, list):
        return len(payload)
    raise SystemExit("Unexpected Ruff report format: expected a list of violations.")


def main() -> int:
    args = parse_args()
    baselines = load_baselines(args.baseline)

    expected_coverage = (
        baselines.get("coverage", {}).get("chatflow_miner.lib")
    )
    expected_violations = baselines.get("ruff", {}).get("violation_count")

    if expected_coverage is None:
        raise SystemExit(
            "Baseline file is missing the coverage value for chatflow_miner.lib."
        )
    if expected_violations is None:
        raise SystemExit("Baseline file is missing the Ruff violation count.")

    actual_coverage = read_coverage_percent(args.coverage)
    actual_violations = read_ruff_violation_count(args.ruff)

    failures = []

    # Allow a tiny epsilon to account for coverage floating-point artefacts.
    epsilon = 1e-6
    if actual_coverage + epsilon < float(expected_coverage):
        failures.append(
            "Coverage decreased: "
            f"expected at least {expected_coverage:.2f}% for chatflow_miner.lib, "
            f"but measured {actual_coverage:.2f}%."
        )

    if actual_violations > int(expected_violations):
        failures.append(
            "Ruff violations increased: "
            f"expected at most {expected_violations} issues, "
            f"but detected {actual_violations}."
        )

    print(
        "Quality gate comparison:\n"
        f"  Expected coverage (chatflow_miner.lib): {float(expected_coverage):.2f}%\n"
        f"  Measured coverage (chatflow_miner.lib): {actual_coverage:.2f}%\n"
        f"  Allowed Ruff violations: {int(expected_violations)}\n"
        f"  Reported Ruff violations: {actual_violations}"
    )

    if failures:
        for failure in failures:
            print(f"::error::{failure}")
        return 1

    print("Quality gates satisfied: coverage and Ruff thresholds met.")
    return 0


if __name__ == "__main__":
    sys.exit(main())
